<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RockBase — ultra‑minimal MVP</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; font-family: system-ui, sans-serif; }
    #hud { position: fixed; left: 12px; top: 12px; background: rgba(0,0,0,.6); color: #fff; padding: 10px 12px; border-radius: 10px; font-size: 14px; }
    #hud button { margin-top: 6px; padding: 6px 10px; border: 0; border-radius: 8px; cursor: pointer; }
    #toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; background: rgba(0,0,0,.75); color:#fff; padding:10px 14px; border-radius: 10px; font-size: 14px; display:none; }
    canvas { display:block; width:100vw; height:100vh; background:#f7f7f7; }
    .kbd { background:#222; padding:2px 6px; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="hud">
    <div><strong>RockBase MVP</strong></div>
    <div>Troops: <span id="troops">0</span></div>
    <div>Building: <span id="bstate">none</span></div>
    <div style="opacity:.8; margin-top:4px">L‑click: place/select • R‑drag: pan • Wheel: zoom • <span class="kbd">B</span>: Build</div>
    <button id="buildBtn">Build (place 1)</button>
  </div>
  <div id="toast"></div>

  <script>
    // --- Canvas setup ---
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    function resize(){
      cvs.width = Math.floor(innerWidth * DPR);
      cvs.height = Math.floor(innerHeight * DPR);
      cvs.style.width = innerWidth + 'px';
      cvs.style.height = innerHeight + 'px';
      ctx.setTransform(DPR,0,0,DPR,0,0); // draw in CSS pixels
    }
    addEventListener('resize', resize);
    resize();

    // --- Simple state & persistence ---
    const STORAGE_KEY = 'rockbase:v0';
    function load(){
      try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || null } catch { return null }
    }
    function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

    const nowMs = () => Date.now();

    const defaultState = {
      rock: { x: 0, y: 0, radius: 200 },
      building: null, // {x, y, placedAt}
      troops: 0,
      lastTick: nowMs(), // ms clock for production
      cam: { x: -innerWidth/2, y: -innerHeight/2, zoom: 1 }, // start with rock centered
    };

    let state = load() || structuredClone(defaultState);

    // accrue troops: 1 per minute if building exists
    function accrue(){
      if(!state.building) return; // no production without building
      const RATE_PER_MIN = 1; // troop/min
      const elapsedMs = nowMs() - state.lastTick;
      const wholeMins = Math.floor(elapsedMs / 60000);
      if(wholeMins > 0){
        state.troops += wholeMins * RATE_PER_MIN;
        state.lastTick += wholeMins * 60000;
        save();
        updateHud();
      }
    }

    // --- Camera helpers ---
    const cam = state.cam;
    const screenToWorld = (sx, sy) => ({ x: sx/cam.zoom + cam.x, y: sy/cam.zoom + cam.y });
    const worldToScreen = (wx, wy) => ({ x: (wx - cam.x)*cam.zoom, y:(wy - cam.y)*cam.zoom });

    // --- Input ---
    let isPanning = false; let last = {x:0,y:0};
    let buildMode = false;

    cvs.addEventListener('contextmenu', e => e.preventDefault());
    cvs.addEventListener('mousedown', (e) => {
      if(e.button === 2){ // right: pan
        isPanning = true; last.x = e.clientX; last.y = e.clientY;
      } else if(e.button === 0){ // left: action
        const p = screenToWorld(e.clientX, e.clientY);
        const r = state.rock;
        const dist = Math.hypot(p.x - r.x, p.y - r.y);
        // click on rock toggles center
        if(dist < 20){
          // center camera on rock
          cam.x = r.x - innerWidth/2 / cam.zoom;
          cam.y = r.y - innerHeight/2 / cam.zoom;
          showToast('Centered on your rock.');
          return;
        }
        if(buildMode){
          if(state.building){ showToast('You already placed your 1 building.'); return; }
          if(dist > r.radius){ showToast('Must build within your territory.'); return; }
          state.building = { x: p.x, y: p.y, placedAt: nowMs() };
          state.lastTick = nowMs();
          save();
          updateHud();
          buildMode = false; updateBuildBtn();
          showToast('Building placed. Troops start producing (1/min).');
        } else {
          // no other actions yet
        }
      }
    });
    addEventListener('mousemove', (e) => {
      if(isPanning){
        const dx = (e.clientX - last.x)/cam.zoom;
        const dy = (e.clientY - last.y)/cam.zoom;
        cam.x -= dx; cam.y -= dy;
        last.x = e.clientX; last.y = e.clientY;
      }
    });
    addEventListener('mouseup', (e)=>{ if(e.button===2) isPanning=false; });
    addEventListener('wheel', (e)=>{
      const prevZoom = cam.zoom;
      const zoomFactor = Math.exp(-e.deltaY * 0.001); // smooth zoom
      const mx = e.clientX, my = e.clientY;
      const before = screenToWorld(mx, my);
      cam.zoom = Math.min(3, Math.max(0.25, cam.zoom * zoomFactor));
      const after = screenToWorld(mx, my);
      cam.x += before.x - after.x; cam.y += before.y - after.y; // zoom to cursor
    }, { passive: true });

    addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='b'){ toggleBuild(); }
    });

    // --- HUD ---
    const $troops = document.getElementById('troops');
    const $bstate = document.getElementById('bstate');
    const $buildBtn = document.getElementById('buildBtn');
    const $toast = document.getElementById('toast');

    function updateHud(){
      $troops.textContent = state.troops;
      $bstate.textContent = state.building ? 'placed' : (buildMode ? 'placing…' : 'none');
    }
    function showToast(msg){
      $toast.textContent = msg; $toast.style.display='block';
      clearTimeout(showToast._t); showToast._t = setTimeout(()=>{ $toast.style.display='none'; }, 1800);
    }
    function toggleBuild(){ buildMode = !buildMode; updateBuildBtn(); updateHud(); }
    function updateBuildBtn(){
      $buildBtn.textContent = state.building ? 'Building placed' : (buildMode ? 'Click on map to place' : 'Build (place 1)');
      $buildBtn.disabled = !!state.building;
    }
    $buildBtn.addEventListener('click', ()=>{ if(!state.building){ buildMode = true; updateBuildBtn(); } });

    updateHud(); updateBuildBtn();

    // --- Render loop ---
    function drawGrid(){
      const step = 100; // world units
      const minx = Math.floor(cam.x/step)*step;
      const miny = Math.floor(cam.y/step)*step;
      const maxx = cam.x + innerWidth / cam.zoom;
      const maxy = cam.y + innerHeight / cam.zoom;
      ctx.lineWidth = 1; ctx.strokeStyle = '#e3e3e3';
      ctx.beginPath();
      for(let x=minx; x<=maxx; x+=step){ const p1 = worldToScreen(x, miny), p2 = worldToScreen(x, maxy); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); }
      for(let y=miny; y<=maxy; y+=step){ const p1 = worldToScreen(minx, y), p2 = worldToScreen(maxx, y); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); }
      ctx.stroke();
    }

    function draw(){
      accrue();
      ctx.clearRect(0,0,innerWidth,innerHeight);
      drawGrid();

      // territory ring
      const r = state.rock; const rockS = worldToScreen(r.x, r.y);
      ctx.beginPath(); ctx.arc(rockS.x, rockS.y, r.radius*cam.zoom, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(64,160,255,0.08)'; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(64,160,255,.6)'; ctx.stroke();

      // rock (base)
      ctx.beginPath(); ctx.arc(rockS.x, rockS.y, 18, 0, Math.PI*2);
      ctx.fillStyle = '#777'; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = '#555'; ctx.stroke();

      // building
      if(state.building){
        const b = worldToScreen(state.building.x, state.building.y);
        const s = 16; ctx.fillStyle = '#333'; ctx.fillRect(b.x - s/2, b.y - s/2, s, s);
      } else if(buildMode){
        // show placement helper if in territory
        cvs.style.cursor = 'crosshair';
      } else {
        cvs.style.cursor = 'default';
      }

      requestAnimationFrame(draw);
    }
    draw();

    // Save every so often as a backup
    setInterval(save, 5000);

    // --- Notes for server upgrade ---
    // This MVP runs fully client-side using localStorage. To make it persistent for all players:
    // 1) Replace localStorage with fetch() calls to a tiny backend that returns current state and
    //    computes troop accrual on the server (authoritative clock). See the chat instructions.
  </script>
</body>
</html>
